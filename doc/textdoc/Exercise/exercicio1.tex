A realização da configuração da ferramenta Captor tem o objetivo de especializar a ferramenta para um domínio especifico e gerar artefatos nesse domínio. Neste exercício, a ferramenta deve gerar scripts SQL e classes Java que realizam a persistência de dados em tabelas relacionais. Na Figura \ref{fig:processo} é apresentado o processo de configuração da ferramenta Captor.

\begin{figure} [!ht]
 \centering
  \bfseries
  \includegraphics [width=0.45\textwidth]{res/processo}
  \caption {Processo de configuração da ferramenta Captor}
  \label{fig:processo}
\end{figure}

Na primeira etapa da configuração da ferramenta deve ser definido a linguagem de modelagem de aplicações (LMA) e baseado nessa linguagem, deve ser desenvolvido o arquivo de configuração principal contendo as definições dos formulários e das regras de validação da especificação. Na segunda etapa são desenvolvidos os arquivos matrizes e os templates. Na terceira etapa, o arquivo de mapeamento de transformação de templates é desenvolvido para indicar para a ferramenta quais templates devem ser utilizados no processo de geração de artefatos.

%------------------------------------------------------------------------------
%------------------------------------------------------------------------------

\subsection{Criação da linguagem de modelagem de aplicações e desenvolvimento do arquivo de configuração principal} \label{subsec:aml}

Para gerar uma aplicação em um domínio particular, é necessário que seja modelado uma linguagem de especificação de aplicações\footnote{Como entrada para o processo de modelagem da linguagem de  aplicações, são necessários os artefatos da análise de domínio e projeto modular \cite{weiss}. A persistência de dados em banco de dados relacionais é uma atividade recorrente durante a programação de aplicações, e por esse motivo, este manual pretende utilizar o conhecimento do leitor no domínio escolhido e omitir as atividades de análise de domínio e projeto modular.}. Essa linguagem é utilizada para descrever aplicações nesse domínio e a sua estrutura deve expressar os parâmetros de variação que as aplicações nesse domínio podem apresentar.

No domínio de persitência, uma classe representa uma tabela do banco de dados e os atributos dessa classe representam uma tupla dessa tabela. As classes persistentes devem fornecer um método para inserir uma tupla em uma tabela, um método para recuperar uma tupla de uma tabela e um método para remover uma tupla de uma tabela.

Os parâmetros de variação necessários para especificar classes persistentes são apresentados na Tabela \ref{tab:variacao}.

\begin{table}[ht]
	\centering
	\caption{Parâmetros de variação}
	\label{tab:variacao}
		
		\begin{tabular}{|p{105pt}|p{300pt}|}

			\hline 
			\hline 

			\hline 
			\textbf{Parâmetro} &  \textbf{Descrição} \\


			\hline 
			Nome do pacote &  O nome do pacote em que as classes devem ser armazenadas. \\
			
			\hline 
			Nome da classe &  O nome da classe persistente que deve ser criada. \\

			\hline 
			Nome da tabela &  O nome da tabela do banco de dados que essa classe representa. \\

			\hline 
			Atributos da classe & O nome dos atributos da classe persistente. \\
			 
			\hline 
			Atributos da tabela & O nome dos atributos da tabela do banco de dados. \\
			
			\hline 
			Tipos dos atributos & O tipo dos atributos da classe e da tabela. \\

			\hline 
		\end{tabular}

	\end{table}

Para simplificar este exercício, uma classe não pode ter associações com outras classes e os tipos válidos dos atributos das classes e das tabelas são apenas os tipos inteiros e \textit{strings}. Como exercício complementar, o leitor pode realizar a configuração completa da ferramenta para o domínio de persistência incluindo diversos tipos de relacionamentos entre classes e apoio para os principais tipos de dados disponíveis nos banco de dados comerciais.

Note que a especificação desses parâmetros de variação disponíveis na Tabela \ref{tab:variacao} não são baseadas na linguagem de programação Java ou na interface de programação JDBC. O objetivo da criação e utilização dessa linguagem é permitir que o engenheiro de aplicação especifique uma aplicação de forma abstrata e obtenha a diminuição do esforço e tempo de desenvolvimento de aplicações nesse domínio por meio da geração dos artefatos.

%------------------------------------------------------------------------------

Para iniciar a parte técnica do processo de configuração, é necessário a criação do arquivo de configuração principal. O arquivo de configuração principal descreve a estrutura dos formulários da especificação, os componentes gráficos que cada formulário contém e as regras de validação dessa especificação. Na Figura \ref{fig:processoConfig} são apresentadas as principais etapasdo processo de desenvolvimento do arquivo de configuração principal.

\begin{figure} [!ht]
 \centering
  \bfseries
  \includegraphics [width=0.30\textwidth]{res/processoConfig}
  \caption {Processo de desenvolvimento da LMA}
  \label{fig:processoConfig}
\end{figure}

%------------------------------------------------------------------------------

\subsubsection{Definição da estrutura de formulários}\label{subsec:arp}

Os formulários são estruturados na ferramenta em forma de árvore. A especificação da aplicação começa com a edição de um formulário raíz que pode conter um ou mais formulários filhos.

Baseado no conhecimento de domínio e no conhecimento funcional da ferramenta, pode ser definida  a seguinte estrutura de formulários para armazenar os parâmetros de variação contidos na Tabela \ref{tab:variacao}:\\

Para o nó raíz da especificação, pode ser definido um formulário com uma caixa de texto contendo a descrição das classes de persitência que estão sendo geradas. As classes persistentes são agrupadas em pacotes. Os pacotes são especificados no nós filhos do formulário raíz. As classes persistentes são especificadas nos formulários filhos do formulário da especificação de pacotes. Os formulários que representam as classes persistentes devem conter um campo para especificar o nome da classe, um campo para especificar o nome da tabela que essa classe representa e um componente gráfico em forma de tabela para descrever o nome e tipo dos atributos das classes e da tabela.

Um formulário de descrição de classes pode ter um ou mais nós filhos com descrição de pacotes e os formulários de especificação de pacotes podem conter um ou mais nós filhos com os formulários da especificação de classes.

Na Figura \ref{fig:formstructure} é apresentado essa estrutura de formulários e as Figuras \ref{fig:projectform}, \ref{fig:packageform} e \ref{fig:classform} apresentam esquematicamente os componentes gráficos de cada formulário da Figura \ref{fig:formstructure}.

\begin{figure} [!ht]
 \centering
  \bfseries
  \includegraphics [width=0.30\textwidth]{res/formstructure}
  \caption {Estrutura de formulários}
  \label{fig:formstructure}
\end{figure}

\begin{figure} [!ht]
 \centering
  \bfseries
  \includegraphics [width=0.55\textwidth]{res/projectform}
  \caption {Formulário de especificação da descrição do projeto}
  \label{fig:projectform}
\end{figure}

\begin{figure} [!ht]
 \centering
  \bfseries
  \includegraphics [width=0.55\textwidth]{res/packageform}
  \caption {Formulário de especificação de pacotes}
  \label{fig:packageform}
\end{figure}

\begin{figure} [!ht]
 \centering
  \bfseries
  \includegraphics [width=0.55\textwidth]{res/classform}
  \caption {Formulário de especificação de classes persistentes}
  \label{fig:classform}
\end{figure}

%------------------------------------------------------------------------------

\subsubsection{Seleção dos componentes}

Para montar os formulários definidos na Sub-seção \ref{subsec:arp} é necessário escolher os componentes de formulário que cada formulário deve conter. Baseado nas Figuras \ref{fig:projectform}, \ref{fig:packageform} e \ref{fig:classform} e no manual de componentes de formulário, o engenheiro de domínio pode escolher os seguintes componentes:\\

\noindent\textbf{Formulário de descrição de projetos}

\begin{itemize}
	\item O componente de formulário TextAreaPanel para definir a descrição do projeto.
\end{itemize}

\noindent\textbf{Formulário de especificação de pacotes:}

\begin{itemize}
	\item O componente de formulário TextPanel para definir o nome dos pacotes.
\end{itemize}

\noindent\textbf{Formulário de especificação de classes:}

\begin{itemize}
	\item O componente de formulário TextPanel para definir o nome da classe.
	\item O componente de formulário TextPanel para definir o nome da tabela.
	\item O componente de formulário TablePanel para definir o nome dos atributos da classe e das tabelas, e os tipos desses atributos.
\end{itemize}

%------------------------------------------------------------------------------

\subsubsection{Definição das regras de validação}

O engenheiro de domínio deve configurar a ferramenta para fazer a validação da especificação da aplicação. A definição das regras de validação tem o objetivo de não permitir que o engenheiro de aplicação gere artefatos à partir de uma especificação inválida.

A ferramenta Captor fornece duas formas de validação: a validação estrutural e a validação sintática. 

A validação estrutural deve asssegurar que não exista nenhum formulário de especificação de pacotes que não contenha pelo menos um formulário filho com a especificação de uma classe e a validação sintática deve ser aplicada nos formulários de especificação de pacotes e nos formulários de especificação de classes. As regras de validação sintática dos dados inseridos nos componentes de formulário são apresentados na Tabela \ref{tab:validate}.

\begin{table}[ht]
	\centering
	\caption{Regras de validação}
	\label{tab:validate}
		
		\begin{tabular}{|p{95pt}|p{340pt}|}

			\hline 
			\hline 

			\hline 
			\textbf{Parâmetro} &  \textbf{Descrição} \\

			\hline 
			Nome do pacote &  O nome do pacote deve ser especificado de acordo com a expressão regular:\\ &([a-zA-Z]+[a-zA-Z$\backslash$-0-9]+)+([$\backslash$$\backslash$/][a-zA-Z]+[a-zA-Z$\backslash$-0-9]+)* \\

			\hline 
			Nome da classe &  O nome da classe deve ser especificada de acordo com a expressão regular:\\ & [A-Z]+([a-zA-Z$\backslash$-0-9]+)*[A-Za-z]+ \\

			\hline 
			Nome da tabela &  O nome da tabela deve ser especificada de acordo com a expressão regular:\\ & [A-Za-z]+([a-zA-Z$\backslash$-\_0-9]+)*[A-Za-z]+  \\
			
			\hline 
			Atributos da classe & O nome dos atributos da classe devem ser especificados de acordo com a expressão regular:\\ & [a-z]+([a-zA-Z$\backslash$-\_0-9]+)*[A-Za-z]+  \\
			
			\hline 
			Colunas da tabela & O nome das colunas da tabela devem ser especificados de acordo com a expressão regular:\\ & [A-Z]+([a-zA-Z$\backslash$-\_0-9]+)*[A-Za-z]+ \\
			
			\hline 
			Tipos dos atributos & Os tipos de dados devem ser especificados de acordo com a expressão regular: \\ & [int]*[String]* \\

			\hline 
		\end{tabular}

	\end{table}

%------------------------------------------------------------------------------
%------------------------------------------------------------------------------

\subsection{Desenvolvimento dos arquivos matrizes e templates}\label{subsec:templates}

Para iniciar o desenvolvimento de \textit{templates} é necessário que exista pelo menos um exemplo de código desenvolvido manualmente. À partir desse exemplo, chamado de exemplo matriz, os \textit{templates} são desenvolvidos.

%------------------------------------------------------------------------------

\subsubsection{Matriz SQL}

Na Listagem \ref{lst:sql} é apresentado o código SQL necessário para realizar a criação de uma tabela no banco de dados MySQL \cite{mysql}.

\lstset{language=sql}
\begin{lstlisting}[caption=Código SQL necessário para criar uma tabela do banco de dados,label=lst:sql]
CREATE TABLE NOME_DA_TABELA 
  (att1 int, att2 int, att3 varchar(50));
\end{lstlisting}

%------------------------------------------------------------------------------

\subsubsection{Matriz de classe persistente (Java - JDBC)}

A Matriz dos código Java que realiza a persistência de uma classe Java é apresentada na Listagem \ref{lst:java}.

\lstset{language=java}
\begin{lstlisting}[caption=Código Java de uma classe persistente,label=lst:java]
package exemplo.persistente;

import java.sql.*;

public class Pessoa  {

  private int id;
  private String nome;
  private int idade;
  private boolean sexo;
	
  private Connection con;
	
  public Pessoa(Connection con)  {
    nome = new String();
    idade = 0;
    id = 0;
    sexo = true;	
    this.con = con;
  }	
	
  //getters and setters
  public int getId()  {
    return id;
  }
  public void setId(int id)  {
    this.id = id;	
  }

  public String getNome()  {
    return nome;
  }
  public void setNome(String nome)  {
    this.nome = nome;	
  }
	
  public int getIdade()  {
    return idade;
  }
  public void setIdade(int idade)  {
    this.idade = idade;	
  }
	
  public boolean getSexo()  {
    return sexo;
  }
  public void setSexo(boolean sexo)  {
    this.sexo = sexo;	
  }

  //persistent methods
  public boolean save()  {
    Statement stmt = null;
		
    //create a query
    String query = ``INSERT INTO PESSOA (ID, NOME, IDADE,SEXO)'';
    query = query + ``VALUES (ID_, 'NOME_', IDADE_,'SEXO_')'';

    //create string data from class attributes
    String idString = new Integer(id).toString();
    String idadeString = new Integer(idade).toString();
    String sexoString = new Boolean(sexo).toString();
    sexoString = sexoString.substring(0,1);
    
    //put the attribute values into the query
    query = query.replaceFirst(``ID_'', idString);
    query = query.replaceFirst(``NOME_'', nome);
    query = query.replaceFirst(``IDADE_'', idadeString);
    query = query.replaceFirst(``SEXO_'', sexoString);
		
    try {
      //create and execute the statement
      stmt = con.createStatement();
      stmt.executeUpdate(query);
    			
      try {
        //close connection
        stmt.close();
        return true;
      } catch (SQLException ex) { 
        System.out.println(ex);
        return false;
      }
    }catch(Exception ex)  {
      System.out.println(ex);
      return false;
    }
  }	
  
  public boolean getById(int id)  {
    Statement stmt = null;
    ResultSet rs = null;
		
    String idString = new Integer(id).toString();

    String query = ``SELECT * FROM PESSOA WHERE ID = ID_'';
    query = query.replaceFirst(``ID_'', idString);
		
    try {
      stmt = con.createStatement();
      rs = stmt.executeQuery(query);
			
      while (rs.next() )  {
        this.id = rs.getInt(``ID'');
        nome = rs.getString(``NOME'');
        idade = rs.getInt(``IDADE'');
        String sx = rs.getString(``SEXO'');
        if ( sx.equals(``t'') )
          sexo = true;
        else
          sexo = false;
      }			
			
      try {
        stmt.close();
        return true;
      } catch (SQLException ex) { 
        System.out.println(ex);
        return false;
      }
    }catch(Exception ex)  {
      System.out.println(ex);
      return false;
    }
		
  }
	
  public boolean delete()  {
    Statement stmt = null;
		
    String idString = new Integer(id).toString();

    String query = ``DELETE FROM PESSOA WHERE ID = ID_'';
    query = query.replaceFirst(``ID_'', idString);
		
    try {
      stmt = con.createStatement();
      stmt.executeUpdate(query);
			
      try {
        stmt.close();
        return true;
      } catch (SQLException ex) { 
        System.out.println(ex);
        return false;
      }
    }catch(Exception ex)  {
      System.out.println(ex);
      return false;
    }
			
 }
	
}
\end{lstlisting}

À partir das matrizes apresentadas nas Listagens \ref{lst:sql} e \ref{lst:java}, o engenheiro de domínio pode iniciar o desenvolvimento dos \textit{templates}.

A linguagen de transformações XSL está fora do escopo desse manual. Instruções
detalhadas da linguagem XSL podem ser encontradas no site: http://
www.w3c.org/xslt e em diversos manuais e livros disponíveis livremente ou para compra
na internet.

No diretório install\_dir/doc/training/XSLT\_examples podem ser encontrados exemplos de transformações XML em ordem progressiva de complexidade. Esses exemplos podem ser executados na linha de comando ou com a ferramenta Ant.

%------------------------------------------------------------------------------

\subsection{Desenvolvimento do arquivo de mapeamento de transformação de templates}\label{subsec:mtl}

O arquivo de mapeamento de transfomação de templates deve informar a ferramenta sobre a necessidade da geração de dois tipos de arquivos: o arquivo com os scripts SQL para a criação das tabelas no banco de dados e as classes Java persistentes.

Para cada projeto deve ser gerado um script SQL e dentro de um projeto, para cada especificação de classe persistente, deve ser criado um arquivo com o nome igual ao nome da classe definida no formulário de especificação de classes.

%------------------------------------------------------------------------------

\subsection{Exercício 1: Configuração da ferramenta}\label{subsec:exercicio1}

Na primeira parte do exercício, o leitor deve configurar a ferramenta Captor com base nos dados fornecidos nesta Seção. As atividades neecessárias para completar o exercício são:

\begin{enumerate}
	\item Criar o arquivo de configuração principal com a definição dos formulários e dos mecanismos de validação.
	\item Criar os templates para gerar o código SQL e os templates para o Código Java.
	\item Criar o arquivo de mapeamento de transformação de templates.
	\item Implantar os artefatos criados na ferramenta.
	\item Testar a nova configuração.
\end{enumerate}

%------------------------------------------------------------------------------